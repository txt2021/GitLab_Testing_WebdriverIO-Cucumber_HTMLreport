{"info":{"type":"runner","start":"2022-11-01T12:38:49.163Z","_duration":13967,"cid":"0-3","capabilities":{"acceptInsecureCerts":true,"browserName":"chrome","browserVersion":"106.0.5249.119","chrome":{"chromedriverVersion":"106.0.5249.61 (511755355844955cd3e264779baf0dd38212a4d0-refs/branch-heads/5249@{#569})","userDataDir":"/tmp/.com.google.Chrome.8Y3wqJ"},"goog:chromeOptions":{"debuggerAddress":"localhost:41157"},"networkConnectionEnabled":false,"pageLoadStrategy":"normal","platformName":"linux","proxy":{},"setWindowRect":true,"strictFileInteractability":false,"timeouts":{"implicit":0,"pageLoad":300000,"script":30000},"unhandledPromptBehavior":"dismiss and notify","webauthn:extension:credBlob":true,"webauthn:extension:largeBlob":true,"webauthn:virtualAuthenticators":true,"sessionId":"ef6f6956f8e83965a5043d0930527dfd"},"sanitizedCapabilities":"chrome.106_0_5249_119.linux","config":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","goog:chromeOptions":{"args":["--headless","--window-size=1500,1000"]},"acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","goog:chromeOptions":{"args":["--headless","--window-size=1500,1000"]},"acceptInsecureCerts":true},"specs":["./features/**/*.feature"],"exclude":[],"suites":{},"baseUrl":"https://about.gitlab.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"cucumber","reporters":[["html-nice",{"outputDir":"./report","linkScreenshots":false,"filename":"report.html","reportTitle":"Test report","showInBrowser":true,"collapseTests":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":1,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"},"specs":["/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/features/Support.feature"],"sessionId":"ef6f6956f8e83965a5043d0930527dfd","isMultiremote":false,"instanceOptions":{"ef6f6956f8e83965a5043d0930527dfd":{"protocol":"http","hostname":"localhost","port":9515,"path":"/","capabilities":{"browserName":"chrome","goog:chromeOptions":{"args":["--headless","--window-size=1500,1000"]},"acceptInsecureCerts":true},"logLevel":"info","connectionRetryTimeout":120000,"connectionRetryCount":3,"logLevels":{},"enableDirectConnect":true,"strictSSL":true,"requestedCapabilities":{"browserName":"chrome","goog:chromeOptions":{"args":["--headless","--window-size=1500,1000"]},"acceptInsecureCerts":true},"specs":["./features/**/*.feature"],"exclude":[],"suites":{},"baseUrl":"https://about.gitlab.com/","bail":0,"waitforInterval":500,"waitforTimeout":10000,"framework":"cucumber","reporters":[["html-nice",{"outputDir":"./report","linkScreenshots":false,"filename":"report.html","reportTitle":"Test report","showInBrowser":true,"collapseTests":false}]],"services":["chromedriver"],"execArgv":[],"maxInstances":1,"maxInstancesPerCapability":100,"filesToWatch":[],"onPrepare":[null],"onWorkerStart":[],"onWorkerEnd":[],"before":[],"beforeSession":[],"beforeSuite":[],"beforeHook":[],"beforeTest":[],"beforeCommand":[],"afterCommand":[],"afterTest":[],"afterHook":[],"afterSuite":[],"afterSession":[],"after":[],"onComplete":[null],"onReload":[],"automationProtocol":"webdriver"}},"retry":0,"failures":0,"retries":0,"end":"2022-11-01T12:39:03.130Z"},"metrics":{"passed":20,"skipped":0,"failed":0,"duration":13967,"start":"2022-11-01T12:38:49.164Z","end":"2022-11-01T12:39:03Z"},"title":"Test report","suites":[{"type":"feature","start":"2022-11-01T12:38:49.204Z","_duration":13872,"tests":[],"hooks":[],"suites":[{"type":"scenario","start":"2022-11-01T12:38:49.228Z","_duration":3219,"tests":[{"type":"test","start":"2022-11-01T12:38:49.230Z","_duration":5,"uid":"25","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"0: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:49.235Z"},{"type":"test","start":"2022-11-01T12:38:49.235Z","_duration":1234,"uid":"26","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"0: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4382e173-026c-44ff-b3b4-b59c5d06507d"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4382e173-026c-44ff-b3b4-b59c5d06507d/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4382e173-026c-44ff-b3b4-b59c5d06507d/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:50.469Z"},{"type":"test","start":"2022-11-01T12:38:50.469Z","_duration":1674,"uid":"27","cid":"0-3","title":"When A user clicks on \"Contact Support\"","fullTitle":"0: When A user clicks on \"Contact Support\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/support/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/support/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"505011c2-c73d-4753-a98c-402ae9322d7f"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/505011c2-c73d-4753-a98c-402ae9322d7f/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/505011c2-c73d-4753-a98c-402ae9322d7f/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:52.143Z"},{"type":"test","start":"2022-11-01T12:38:52.143Z","_duration":303,"uid":"28","cid":"0-3","title":"Then \"GitLab Support\" title was displayed. User was redirected to the \"https://about.gitlab.com/support/\" page","fullTitle":"0: Then \"GitLab Support\" title was displayed. User was redirected to the \"https://about.gitlab.com/support/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14","ELEMENT":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14","ELEMENT":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a92eab66-b9e4-429d-8f4e-9bfef9748e14/text","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a92eab66-b9e4-429d-8f4e-9bfef9748e14/text","body":{},"result":{"value":"GitLab Support"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/support/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:52.446Z"}],"hooks":[{"type":"hook","start":"2022-11-01T12:38:49.229Z","_duration":1,"uid":"70","cid":"0-3","title":"","parent":"0","errors":[],"end":"2022-11-01T12:38:49.230Z"},{"type":"hook","start":"2022-11-01T12:38:52.446Z","_duration":1,"uid":"75","cid":"0-3","title":"","parent":"0","errors":[],"end":"2022-11-01T12:38:52.447Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-11-01T12:38:49.229Z","_duration":1,"uid":"70","cid":"0-3","title":"","parent":"0","errors":[],"end":"2022-11-01T12:38:49.230Z"},{"type":"test","start":"2022-11-01T12:38:49.230Z","_duration":5,"uid":"25","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"0: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:49.235Z"},{"type":"test","start":"2022-11-01T12:38:49.235Z","_duration":1234,"uid":"26","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"0: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"4382e173-026c-44ff-b3b4-b59c5d06507d"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/4382e173-026c-44ff-b3b4-b59c5d06507d/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/4382e173-026c-44ff-b3b4-b59c5d06507d/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:50.469Z"},{"type":"test","start":"2022-11-01T12:38:50.469Z","_duration":1674,"uid":"27","cid":"0-3","title":"When A user clicks on \"Contact Support\"","fullTitle":"0: When A user clicks on \"Contact Support\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/support/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/support/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"505011c2-c73d-4753-a98c-402ae9322d7f"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/505011c2-c73d-4753-a98c-402ae9322d7f/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/505011c2-c73d-4753-a98c-402ae9322d7f/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:52.143Z"},{"type":"test","start":"2022-11-01T12:38:52.143Z","_duration":303,"uid":"28","cid":"0-3","title":"Then \"GitLab Support\" title was displayed. User was redirected to the \"https://about.gitlab.com/support/\" page","fullTitle":"0: Then \"GitLab Support\" title was displayed. User was redirected to the \"https://about.gitlab.com/support/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14","ELEMENT":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14","ELEMENT":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"a92eab66-b9e4-429d-8f4e-9bfef9748e14"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/a92eab66-b9e4-429d-8f4e-9bfef9748e14/text","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/a92eab66-b9e4-429d-8f4e-9bfef9748e14/text","body":{},"result":{"value":"GitLab Support"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/support/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"0","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:52.446Z"},{"type":"hook","start":"2022-11-01T12:38:52.446Z","_duration":1,"uid":"75","cid":"0-3","title":"","parent":"0","errors":[],"end":"2022-11-01T12:38:52.447Z"}],"uid":"0","cid":"0-3","file":"/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/features/Support.feature","title":"TC16 - Should navigate user to Contact Support","fullTitle":"Support.feature:1:1: TC16 - Should navigate user to Contact Support","tags":[],"parent":"Support.feature:1:1","end":"2022-11-01T12:38:52.447Z"},{"type":"scenario","start":"2022-11-01T12:38:52.448Z","_duration":2549,"tests":[{"type":"test","start":"2022-11-01T12:38:52.448Z","_duration":1,"uid":"30","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"1: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:52.449Z"},{"type":"test","start":"2022-11-01T12:38:52.449Z","_duration":1169,"uid":"31","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"1: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d8e26f6e-ab92-4269-b8c5-f50d0d5ada37"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d8e26f6e-ab92-4269-b8c5-f50d0d5ada37/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d8e26f6e-ab92-4269-b8c5-f50d0d5ada37/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:53.618Z"},{"type":"test","start":"2022-11-01T12:38:53.618Z","_duration":1106,"uid":"32","cid":"0-3","title":"When A user clicks on \"Get Help\"","fullTitle":"1: When A user clicks on \"Get Help\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/get-help/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/get-help/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"75b7f717-81c7-4507-92b4-da015fd7cfb5"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/75b7f717-81c7-4507-92b4-da015fd7cfb5/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/75b7f717-81c7-4507-92b4-da015fd7cfb5/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:54.724Z"},{"type":"test","start":"2022-11-01T12:38:54.724Z","_duration":272,"uid":"33","cid":"0-3","title":"Then \"Help Topics\" title was displayed. User was redirected to the \"https://about.gitlab.com/get-help/\" page","fullTitle":"1: Then \"Help Topics\" title was displayed. User was redirected to the \"https://about.gitlab.com/get-help/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526","ELEMENT":"32435a3f-484b-42af-a8cd-e9eda0243526"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526","ELEMENT":"32435a3f-484b-42af-a8cd-e9eda0243526"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/32435a3f-484b-42af-a8cd-e9eda0243526/text","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/32435a3f-484b-42af-a8cd-e9eda0243526/text","body":{},"result":{"value":"Help Topics"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/get-help/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:54.996Z"}],"hooks":[{"type":"hook","start":"2022-11-01T12:38:52.448Z","_duration":0,"uid":"77","cid":"0-3","title":"","parent":"1","errors":[],"end":"2022-11-01T12:38:52.448Z"},{"type":"hook","start":"2022-11-01T12:38:54.996Z","_duration":1,"uid":"82","cid":"0-3","title":"","parent":"1","errors":[],"end":"2022-11-01T12:38:54.997Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-11-01T12:38:52.448Z","_duration":0,"uid":"77","cid":"0-3","title":"","parent":"1","errors":[],"end":"2022-11-01T12:38:52.448Z"},{"type":"test","start":"2022-11-01T12:38:52.448Z","_duration":1,"uid":"30","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"1: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:52.449Z"},{"type":"test","start":"2022-11-01T12:38:52.449Z","_duration":1169,"uid":"31","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"1: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"d8e26f6e-ab92-4269-b8c5-f50d0d5ada37"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/d8e26f6e-ab92-4269-b8c5-f50d0d5ada37/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/d8e26f6e-ab92-4269-b8c5-f50d0d5ada37/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:53.618Z"},{"type":"test","start":"2022-11-01T12:38:53.618Z","_duration":1106,"uid":"32","cid":"0-3","title":"When A user clicks on \"Get Help\"","fullTitle":"1: When A user clicks on \"Get Help\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/get-help/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/get-help/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"75b7f717-81c7-4507-92b4-da015fd7cfb5"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/75b7f717-81c7-4507-92b4-da015fd7cfb5/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/75b7f717-81c7-4507-92b4-da015fd7cfb5/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:54.724Z"},{"type":"test","start":"2022-11-01T12:38:54.724Z","_duration":272,"uid":"33","cid":"0-3","title":"Then \"Help Topics\" title was displayed. User was redirected to the \"https://about.gitlab.com/get-help/\" page","fullTitle":"1: Then \"Help Topics\" title was displayed. User was redirected to the \"https://about.gitlab.com/get-help/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526","ELEMENT":"32435a3f-484b-42af-a8cd-e9eda0243526"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526","ELEMENT":"32435a3f-484b-42af-a8cd-e9eda0243526"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[role=\"main\"] h1"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"32435a3f-484b-42af-a8cd-e9eda0243526"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/32435a3f-484b-42af-a8cd-e9eda0243526/text","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/32435a3f-484b-42af-a8cd-e9eda0243526/text","body":{},"result":{"value":"Help Topics"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/get-help/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"1","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:54.996Z"},{"type":"hook","start":"2022-11-01T12:38:54.996Z","_duration":1,"uid":"82","cid":"0-3","title":"","parent":"1","errors":[],"end":"2022-11-01T12:38:54.997Z"}],"uid":"1","cid":"0-3","file":"/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/features/Support.feature","title":"TC17 - Should navigate user to Get Help page","fullTitle":"Support.feature:1:1: TC17 - Should navigate user to Get Help page","tags":[],"parent":"Support.feature:1:1","end":"2022-11-01T12:38:54.997Z"},{"type":"scenario","start":"2022-11-01T12:38:54.997Z","_duration":2632,"tests":[{"type":"test","start":"2022-11-01T12:38:54.997Z","_duration":5,"uid":"35","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"2: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:55.002Z"},{"type":"test","start":"2022-11-01T12:38:55.002Z","_duration":859,"uid":"36","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"2: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5cca4ce4-33da-48ce-b337-cc68d26d58a1"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5cca4ce4-33da-48ce-b337-cc68d26d58a1/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5cca4ce4-33da-48ce-b337-cc68d26d58a1/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:55.861Z"},{"type":"test","start":"2022-11-01T12:38:55.862Z","_duration":1761,"uid":"37","cid":"0-3","title":"When A user clicks on \"Set up support services\"","fullTitle":"2: When A user clicks on \"Set up support services\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/services/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/services/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fe44be8d-a9ae-491c-b518-aea6226f92fd"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fe44be8d-a9ae-491c-b518-aea6226f92fd/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fe44be8d-a9ae-491c-b518-aea6226f92fd/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:57.623Z"},{"type":"test","start":"2022-11-01T12:38:57.623Z","_duration":6,"uid":"38","cid":"0-3","title":"Then \"GitLab Professional Services\" title was displayed. User was redirected to the \"https://about.gitlab.com/services/\" page","fullTitle":"2: Then \"GitLab Professional Services\" title was displayed. User was redirected to the \"https://about.gitlab.com/services/\" page","output":[{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/services/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:57.629Z"}],"hooks":[{"type":"hook","start":"2022-11-01T12:38:54.997Z","_duration":0,"uid":"84","cid":"0-3","title":"","parent":"2","errors":[],"end":"2022-11-01T12:38:54.997Z"},{"type":"hook","start":"2022-11-01T12:38:57.629Z","_duration":0,"uid":"89","cid":"0-3","title":"","parent":"2","errors":[],"end":"2022-11-01T12:38:57.629Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-11-01T12:38:54.997Z","_duration":0,"uid":"84","cid":"0-3","title":"","parent":"2","errors":[],"end":"2022-11-01T12:38:54.997Z"},{"type":"test","start":"2022-11-01T12:38:54.997Z","_duration":5,"uid":"35","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"2: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:55.002Z"},{"type":"test","start":"2022-11-01T12:38:55.002Z","_duration":859,"uid":"36","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"2: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"5cca4ce4-33da-48ce-b337-cc68d26d58a1"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/5cca4ce4-33da-48ce-b337-cc68d26d58a1/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/5cca4ce4-33da-48ce-b337-cc68d26d58a1/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:55.861Z"},{"type":"test","start":"2022-11-01T12:38:55.862Z","_duration":1761,"uid":"37","cid":"0-3","title":"When A user clicks on \"Set up support services\"","fullTitle":"2: When A user clicks on \"Set up support services\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/services/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/services/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"fe44be8d-a9ae-491c-b518-aea6226f92fd"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/fe44be8d-a9ae-491c-b518-aea6226f92fd/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/fe44be8d-a9ae-491c-b518-aea6226f92fd/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:57.623Z"},{"type":"test","start":"2022-11-01T12:38:57.623Z","_duration":6,"uid":"38","cid":"0-3","title":"Then \"GitLab Professional Services\" title was displayed. User was redirected to the \"https://about.gitlab.com/services/\" page","fullTitle":"2: Then \"GitLab Professional Services\" title was displayed. User was redirected to the \"https://about.gitlab.com/services/\" page","output":[{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/services/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"2","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:57.629Z"},{"type":"hook","start":"2022-11-01T12:38:57.629Z","_duration":0,"uid":"89","cid":"0-3","title":"","parent":"2","errors":[],"end":"2022-11-01T12:38:57.629Z"}],"uid":"2","cid":"0-3","file":"/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/features/Support.feature","title":"TC18 - Should navigate user to GitLab Professional Services","fullTitle":"Support.feature:1:1: TC18 - Should navigate user to GitLab Professional Services","tags":[],"parent":"Support.feature:1:1","end":"2022-11-01T12:38:57.629Z"},{"type":"scenario","start":"2022-11-01T12:38:57.629Z","_duration":2753,"tests":[{"type":"test","start":"2022-11-01T12:38:57.629Z","_duration":2,"uid":"40","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"3: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:57.631Z"},{"type":"test","start":"2022-11-01T12:38:57.632Z","_duration":810,"uid":"41","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"3: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0f5d148f-1c7b-4b70-b0d4-ac26987bc36e"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0f5d148f-1c7b-4b70-b0d4-ac26987bc36e/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0f5d148f-1c7b-4b70-b0d4-ac26987bc36e/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:58.442Z"},{"type":"test","start":"2022-11-01T12:38:58.442Z","_duration":1718,"uid":"42","cid":"0-3","title":"When A user clicks on \"Contact Sales\"","fullTitle":"3: When A user clicks on \"Contact Sales\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/sales/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/sales/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"384348f6-537e-4d3a-9207-3a7c2dd921cc"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/384348f6-537e-4d3a-9207-3a7c2dd921cc/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/384348f6-537e-4d3a-9207-3a7c2dd921cc/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:00.160Z"},{"type":"test","start":"2022-11-01T12:39:00.160Z","_duration":222,"uid":"43","cid":"0-3","title":"Then \"Talk to an Expert\" title was displayed. User was redirected to the \"https://about.gitlab.com/sales/\" page","fullTitle":"3: Then \"Talk to an Expert\" title was displayed. User was redirected to the \"https://about.gitlab.com/sales/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939","ELEMENT":"3531c94b-d709-4ca0-87e9-1b62366a1939"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939","ELEMENT":"3531c94b-d709-4ca0-87e9-1b62366a1939"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3531c94b-d709-4ca0-87e9-1b62366a1939/text","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3531c94b-d709-4ca0-87e9-1b62366a1939/text","body":{},"result":{"value":"Talk to an Expert"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"form_container\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"form_container\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3634802f-ed6e-4788-a7a3-fd20d218246e"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3634802f-ed6e-4788-a7a3-fd20d218246e","ELEMENT":"3634802f-ed6e-4788-a7a3-fd20d218246e"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3634802f-ed6e-4788-a7a3-fd20d218246e","ELEMENT":"3634802f-ed6e-4788-a7a3-fd20d218246e"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/sales/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:00.382Z"}],"hooks":[{"type":"hook","start":"2022-11-01T12:38:57.629Z","_duration":0,"uid":"91","cid":"0-3","title":"","parent":"3","errors":[],"end":"2022-11-01T12:38:57.629Z"},{"type":"hook","start":"2022-11-01T12:39:00.382Z","_duration":0,"uid":"96","cid":"0-3","title":"","parent":"3","errors":[],"end":"2022-11-01T12:39:00.382Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-11-01T12:38:57.629Z","_duration":0,"uid":"91","cid":"0-3","title":"","parent":"3","errors":[],"end":"2022-11-01T12:38:57.629Z"},{"type":"test","start":"2022-11-01T12:38:57.629Z","_duration":2,"uid":"40","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"3: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:57.631Z"},{"type":"test","start":"2022-11-01T12:38:57.632Z","_duration":810,"uid":"41","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"3: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"0f5d148f-1c7b-4b70-b0d4-ac26987bc36e"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/0f5d148f-1c7b-4b70-b0d4-ac26987bc36e/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/0f5d148f-1c7b-4b70-b0d4-ac26987bc36e/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:38:58.442Z"},{"type":"test","start":"2022-11-01T12:38:58.442Z","_duration":1718,"uid":"42","cid":"0-3","title":"When A user clicks on \"Contact Sales\"","fullTitle":"3: When A user clicks on \"Contact Sales\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/sales/\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"ul[class=\"support-dropdown_item\"] li>a[href=\"/sales/\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"384348f6-537e-4d3a-9207-3a7c2dd921cc"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/384348f6-537e-4d3a-9207-3a7c2dd921cc/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/384348f6-537e-4d3a-9207-3a7c2dd921cc/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:00.160Z"},{"type":"test","start":"2022-11-01T12:39:00.160Z","_duration":222,"uid":"43","cid":"0-3","title":"Then \"Talk to an Expert\" title was displayed. User was redirected to the \"https://about.gitlab.com/sales/\" page","fullTitle":"3: Then \"Talk to an Expert\" title was displayed. User was redirected to the \"https://about.gitlab.com/sales/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939","ELEMENT":"3531c94b-d709-4ca0-87e9-1b62366a1939"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939","ELEMENT":"3531c94b-d709-4ca0-87e9-1b62366a1939"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"h1[data-aos=\"zoom-in-up\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3531c94b-d709-4ca0-87e9-1b62366a1939"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/element/3531c94b-d709-4ca0-87e9-1b62366a1939/text","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/element/3531c94b-d709-4ca0-87e9-1b62366a1939/text","body":{},"result":{"value":"Talk to an Expert"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"form_container\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"form_container\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"3634802f-ed6e-4788-a7a3-fd20d218246e"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3634802f-ed6e-4788-a7a3-fd20d218246e","ELEMENT":"3634802f-ed6e-4788-a7a3-fd20d218246e"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"3634802f-ed6e-4788-a7a3-fd20d218246e","ELEMENT":"3634802f-ed6e-4788-a7a3-fd20d218246e"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://about.gitlab.com/sales/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"3","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:00.382Z"},{"type":"hook","start":"2022-11-01T12:39:00.382Z","_duration":0,"uid":"96","cid":"0-3","title":"","parent":"3","errors":[],"end":"2022-11-01T12:39:00.382Z"}],"uid":"3","cid":"0-3","file":"/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/features/Support.feature","title":"TC19 - Should navigate user to Talk to an Expert page","fullTitle":"Support.feature:1:1: TC19 - Should navigate user to Talk to an Expert page","tags":[],"parent":"Support.feature:1:1","end":"2022-11-01T12:39:00.383Z"},{"type":"scenario","start":"2022-11-01T12:39:00.383Z","_duration":2692,"tests":[{"type":"test","start":"2022-11-01T12:39:00.383Z","_duration":2,"uid":"45","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"4: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:00.385Z"},{"type":"test","start":"2022-11-01T12:39:00.385Z","_duration":830,"uid":"46","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"4: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cefa5cae-9965-4898-a29d-b562171c0064"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cefa5cae-9965-4898-a29d-b562171c0064/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cefa5cae-9965-4898-a29d-b562171c0064/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:01.215Z"},{"type":"test","start":"2022-11-01T12:39:01.215Z","_duration":1791,"uid":"47","cid":"0-3","title":"When A user clicks on \"Register1\"","fullTitle":"4: When A user clicks on \"Register1\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-nav=\"register\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-nav=\"register\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b941527b-21ad-4005-8e1f-d67f6284589a"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b941527b-21ad-4005-8e1f-d67f6284589a/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b941527b-21ad-4005-8e1f-d67f6284589a/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:03.006Z"},{"type":"test","start":"2022-11-01T12:39:03.006Z","_duration":69,"uid":"48","cid":"0-3","title":"Then \"Sign Up form\" title was displayed. User was redirected to the \"https://gitlab.com/users/sign_up/\" page","fullTitle":"4: Then \"Sign Up form\" title was displayed. User was redirected to the \"https://gitlab.com/users/sign_up/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"signup-page\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"signup-page\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"510518ea-fdaa-4b2f-a237-f15044ff29d5"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"510518ea-fdaa-4b2f-a237-f15044ff29d5","ELEMENT":"510518ea-fdaa-4b2f-a237-f15044ff29d5"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"510518ea-fdaa-4b2f-a237-f15044ff29d5","ELEMENT":"510518ea-fdaa-4b2f-a237-f15044ff29d5"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://gitlab.com/users/sign_up/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:03.075Z"}],"hooks":[{"type":"hook","start":"2022-11-01T12:39:00.383Z","_duration":0,"uid":"98","cid":"0-3","title":"","parent":"4","errors":[],"end":"2022-11-01T12:39:00.383Z"},{"type":"hook","start":"2022-11-01T12:39:03.075Z","_duration":0,"uid":"103","cid":"0-3","title":"","parent":"4","errors":[],"end":"2022-11-01T12:39:03.075Z"}],"suites":[],"hooksAndTests":[{"type":"hook","start":"2022-11-01T12:39:00.383Z","_duration":0,"uid":"98","cid":"0-3","title":"","parent":"4","errors":[],"end":"2022-11-01T12:39:00.383Z"},{"type":"test","start":"2022-11-01T12:39:00.383Z","_duration":2,"uid":"45","cid":"0-3","title":"Given A user open main GitLab page","fullTitle":"4: Given A user open main GitLab page","output":[{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:00.385Z"},{"type":"test","start":"2022-11-01T12:39:00.385Z","_duration":830,"uid":"46","cid":"0-3","title":"When A user clicks on \"Support\" button","fullTitle":"4: When A user clicks on \"Support\" button","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/url","body":{"url":"https://about.gitlab.com/"},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[id=\"supportDropdown\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"cefa5cae-9965-4898-a29d-b562171c0064"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/cefa5cae-9965-4898-a29d-b562171c0064/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/cefa5cae-9965-4898-a29d-b562171c0064/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:01.215Z"},{"type":"test","start":"2022-11-01T12:39:01.215Z","_duration":1791,"uid":"47","cid":"0-3","title":"When A user clicks on \"Register1\"","fullTitle":"4: When A user clicks on \"Register1\"","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-nav=\"register\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"[data-nav=\"register\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"b941527b-21ad-4005-8e1f-d67f6284589a"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/element/b941527b-21ad-4005-8e1f-d67f6284589a/click","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element/b941527b-21ad-4005-8e1f-d67f6284589a/click","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:03.006Z"},{"type":"test","start":"2022-11-01T12:39:03.006Z","_duration":69,"uid":"48","cid":"0-3","title":"Then \"Sign Up form\" title was displayed. User was redirected to the \"https://gitlab.com/users/sign_up/\" page","fullTitle":"4: Then \"Sign Up form\" title was displayed. User was redirected to the \"https://gitlab.com/users/sign_up/\" page","output":[{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"signup-page\"]"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/element","body":{"using":"css selector","value":"div[class=\"signup-page\"]"},"result":{"value":{"element-6066-11e4-a52e-4f735466cecf":"510518ea-fdaa-4b2f-a237-f15044ff29d5"}},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"510518ea-fdaa-4b2f-a237-f15044ff29d5","ELEMENT":"510518ea-fdaa-4b2f-a237-f15044ff29d5"}]},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"POST","endpoint":"/session/:sessionId/execute/sync","body":{"script":"return (function isElementDisplayed(element) {\n    function nodeIsElement(node) {\n        if (!node) {\n            return false;\n        }\n        switch (node.nodeType) {\n            case Node.ELEMENT_NODE:\n            case Node.DOCUMENT_NODE:\n            case Node.DOCUMENT_FRAGMENT_NODE:\n                return true;\n            default:\n                return false;\n        }\n    }\n    function parentElementForElement(element) {\n        if (!element) {\n            return null;\n        }\n        return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);\n    }\n    function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {\n        for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode)\n            if (predicate(node)) {\n                return node;\n            }\n        return null;\n    }\n    function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {\n        for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element))\n            if (predicate(element)) {\n                return element;\n            }\n        return null;\n    }\n    function cascadedStylePropertyForElement(element, property) {\n        if (!element || !property) {\n            return null;\n        }\n        // if document-fragment, skip it and use element.host instead. This happens\n        // when the element is inside a shadow root.\n        // window.getComputedStyle errors on document-fragment.\n        if (element instanceof ShadowRoot) {\n            element = element.host;\n        }\n        let computedStyle = window.getComputedStyle(element);\n        let computedStyleProperty = computedStyle.getPropertyValue(property);\n        if (computedStyleProperty && computedStyleProperty !== 'inherit') {\n            return computedStyleProperty;\n        }\n        // Ideally getPropertyValue would return the 'used' or 'actual' value, but\n        // it doesn't for legacy reasons. So we need to do our own poor man's cascade.\n        // Fall back to the first non-'inherit' value found in an ancestor.\n        // In any case, getPropertyValue will not return 'initial'.\n        // FIXME: will this incorrectly inherit non-inheritable CSS properties?\n        // I think all important non-inheritable properties (width, height, etc.)\n        // for our purposes here are specially resolved, so this may not be an issue.\n        // Specification is here: https://drafts.csswg.org/cssom/#resolved-values\n        let parentElement = parentElementForElement(element);\n        return cascadedStylePropertyForElement(parentElement, property);\n    }\n    function elementSubtreeHasNonZeroDimensions(element) {\n        let boundingBox = element.getBoundingClientRect();\n        if (boundingBox.width > 0 && boundingBox.height > 0) {\n            return true;\n        }\n        // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.\n        if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {\n            let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');\n            return !!strokeWidth && (parseInt(strokeWidth, 10) > 0);\n        }\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow === 'hidden') {\n            return false;\n        }\n        // If the container's overflow is not hidden and it has zero size, consider the\n        // container to have non-zero dimensions if a child node has non-zero dimensions.\n        return Array.from(element.childNodes).some((childNode) => {\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return true;\n            }\n            if (nodeIsElement(childNode)) {\n                return elementSubtreeHasNonZeroDimensions(childNode);\n            }\n            return false;\n        });\n    }\n    function elementOverflowsContainer(element) {\n        let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');\n        if (cascadedOverflow !== 'hidden') {\n            return false;\n        }\n        // FIXME: this needs to take into account the scroll position of the element,\n        // the display modes of it and its ancestors, and the container it overflows.\n        // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.\n        return true;\n    }\n    function isElementSubtreeHiddenByOverflow(element) {\n        if (!element) {\n            return false;\n        }\n        if (!elementOverflowsContainer(element)) {\n            return false;\n        }\n        if (!element.childNodes.length) {\n            return false;\n        }\n        // This element's subtree is hidden by overflow if all child subtrees are as well.\n        return Array.from(element.childNodes).every((childNode) => {\n            // Returns true if the child node is overflowed or otherwise hidden.\n            // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.\n            // Visibility of text nodes is controlled by parent\n            if (childNode.nodeType === Node.TEXT_NODE) {\n                return false;\n            }\n            if (!nodeIsElement(childNode)) {\n                return true;\n            }\n            if (!elementSubtreeHasNonZeroDimensions(childNode)) {\n                return true;\n            }\n            // Recurse.\n            return isElementSubtreeHiddenByOverflow(childNode);\n        });\n    }\n    // walk up the tree testing for a shadow root\n    function isElementInsideShadowRoot(element) {\n        if (!element) {\n            return false;\n        }\n        if (element.parentNode && element.parentNode.host) {\n            return true;\n        }\n        return isElementInsideShadowRoot(element.parentNode);\n    }\n    // This is a partial reimplementation of Selenium's \"element is displayed\" algorithm.\n    // When the W3C specification's algorithm stabilizes, we should implement that.\n    // If this command is misdirected to the wrong document (and is NOT inside a shadow root), treat it as not shown.\n    if (!isElementInsideShadowRoot(element) && !document.contains(element)) {\n        return false;\n    }\n    // Special cases for specific tag names.\n    switch (element.tagName.toUpperCase()) {\n        case 'BODY':\n            return true;\n        case 'SCRIPT':\n        case 'NOSCRIPT':\n            return false;\n        case 'OPTGROUP':\n        case 'OPTION': {\n            // Option/optgroup are considered shown if the containing <select> is shown.\n            let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, (e) => e.tagName.toUpperCase() === 'SELECT');\n            return isElementDisplayed(enclosingSelectElement);\n        }\n        case 'INPUT':\n            // <input type=\"hidden\"> is considered not shown.\n            if (element.type === 'hidden') {\n                return false;\n            }\n            break;\n        // case 'MAP':\n        // FIXME: Selenium has special handling for <map> elements. We don't do anything now.\n        default:\n            break;\n    }\n    if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') {\n        return false;\n    }\n    let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;\n    });\n    let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, (e) => {\n        return cascadedStylePropertyForElement(e, 'display') === 'none';\n    });\n    if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) {\n        return false;\n    }\n    if (!elementSubtreeHasNonZeroDimensions(element)) {\n        return false;\n    }\n    if (isElementSubtreeHiddenByOverflow(element)) {\n        return false;\n    }\n    return true;\n}).apply(null, arguments)","args":[{"element-6066-11e4-a52e-4f735466cecf":"510518ea-fdaa-4b2f-a237-f15044ff29d5","ELEMENT":"510518ea-fdaa-4b2f-a237-f15044ff29d5"}]},"result":{"value":true},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"GET","endpoint":"/session/:sessionId/url","body":{},"result":{"value":"https://gitlab.com/users/sign_up/"},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"command"},{"method":"DELETE","endpoint":"/session/:sessionId","body":{},"result":{"value":null},"sessionId":"ef6f6956f8e83965a5043d0930527dfd","cid":"0-3","type":"result"}],"retries":0,"parent":"4","state":"passed","events":[],"errorIndex":0,"end":"2022-11-01T12:39:03.075Z"},{"type":"hook","start":"2022-11-01T12:39:03.075Z","_duration":0,"uid":"103","cid":"0-3","title":"","parent":"4","errors":[],"end":"2022-11-01T12:39:03.075Z"}],"uid":"4","cid":"0-3","file":"/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/features/Support.feature","title":"TC20 - Should navigate user to registration page","fullTitle":"Support.feature:1:1: TC20 - Should navigate user to registration page","tags":[],"parent":"Support.feature:1:1","end":"2022-11-01T12:39:03.076Z"}],"hooksAndTests":[],"uid":"Support.feature:1:1","cid":"0-3","file":"/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/features/Support.feature","title":"Support services","tags":[],"description":"","end":"2022-11-01T12:39:03.077Z"}],"reportFile":"/home/runner/work/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/GitLab_Testing_WebdriverIO-Cucumber_HTMLreport/report/report-0-3.html","browserName":"not specified"}